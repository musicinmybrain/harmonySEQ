/*
    Copyright (C) 2010 Rafał Cieślak

    This file is part of harmonySEQ.

    HarmonySEQ is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    HarmonySEQ is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with HarmonySEQ.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <fstream>
#include "Files.h"
#include "messages.h"
#include "Sequencer.h"
#include "MainWindow.h"
#include "Event.h"
#include "EventsWindow.h"
#include "Action.h"
#include "MidiDriver.h"

namespace Files {

     bool file_modified;
    Glib::ustring file_name;
    Glib::ustring file_dir;
    
bool fexists(const char *filename)
{
   //Trick used to tell whether a file exists.
  ifstream ifile(filename);
  //Returns 1 if opening file succeeded, 0 elsewhere.
  return ifile;
}

bool SetFileModified(bool modified){
    if (modified != file_modified){
        file_modified = modified;
        mainwindow->UpdateTitle();
    }
    else
        file_modified = modified;

    return file_modified;
}

void SaveToFile(Glib::ustring filename){

    //The keyfile intepreter.
    Glib::KeyFile kf;

    //temporary strings
    char temp[300];
    char temp2[300];

    //The output file stream we'll put the data into.
    ofstream output_file;

    //Trying to open the file, using Truncate mode.
    output_file.open(filename.c_str(),ios_base::trunc);

    //If something went wrong...
    if(!output_file.good()){
        sprintf(temp,_("ERROR - error while opening file %s to write.\n"),filename.c_str());
        //Inform the user about the mistake both by STDIO and a nice graphical MessageBox.
        *err << temp;
        Info(temp);
    }

    //The comment in the very first line of .hseq file.
    sprintf(temp,"harmonyseq file, generated by harmonySEQ %s. Manual editing not suggested, since the program does not check whether the data here is correct - may cause crashes.",VERSION);
    kf.set_comment(temp);

    //Setting some basic data...
    kf.set_string("harmonySEQ","version",VERSION);
    kf.set_integer("harmonySEQ","versionA",VERSION_A);
    kf.set_integer("harmonySEQ","versionB",VERSION_B);
    kf.set_integer("harmonySEQ","versionC",VERSION_C);
    kf.set_double(FILE_GROUP_SYSTEM,FILE_KEY_SYSTEM_TEMPO,tempo);
    kf.set_integer(FILE_GROUP_SYSTEM,FILE_KEY_SYSTEM_MAINNOTE,mainnote);
    kf.set_integer(FILE_GROUP_SYSTEM,FILE_KEY_SYSTEM_SEQ_NUM,sequencers.size());
    kf.set_integer(FILE_GROUP_SYSTEM,FILE_KEY_SYSTEM_EVENTS_NUM,events.size());

    //And now, save the sequencers.
    //For each sequencer...
    for (unsigned int x = 0; x < sequencers.size(); x++){
        if(sequencers[x] == NULL) continue; //Skip this sequencer, if it was removed.
        //Prepare the KEY for this sequencer, according to the pattern in FILE_GROUP_TEMPLATE_SEQ, it will be used to store all  values of this sequencer.
        sprintf(temp,FILE_GROUP_TEMPLATE_SEQ,x);
        //And store the values, as follows:
        kf.set_string(temp,FILE_KEY_SEQ_NAME,sequencers[x]->GetName());
        kf.set_boolean(temp,FILE_KEY_SEQ_ON,sequencers[x]->GetOn());
        kf.set_integer(temp,FILE_KEY_SEQ_CHANNEL,sequencers[x]->GetChannel());
        kf.set_boolean(temp,FILE_KEY_SEQ_APPLY_MAIN_NOTE,sequencers[x]->GetApplyMainNote());
        kf.set_integer(temp,FILE_KEY_SEQ_VOLUME,sequencers[x]->GetVolume());
        kf.set_integer(temp,FILE_KEY_SEQ_RESOLUTION,sequencers[x]->resolution);
        kf.set_double(temp,FILE_KEY_SEQ_LENGTH,sequencers[x]->length);
        kf.set_integer(temp,FILE_KEY_SEQ_PATTERNS_NUMBER,sequencers[x]->patterns.size());
        //Now, save the patterns.
        //For each pattern in this sequencer...
        for (int s=0; s<sequencers[x]->patterns.size();s++){
            //Prepatre the value name for this pattern, according to FILE_KEY_SEQ_PATTERN_TEMPLATE.
            sprintf(temp2,FILE_KEY_SEQ_PATTERN_TEMPLATE,s);
            //Convert sequencer notes of this pattern, which is a 2-dimentional array, into one dimentional vector
            vector<int> S(sequencers[x]->resolution*6);
            for (int r = 0; r < sequencers[x]->resolution; r++){
                for (int c = 0; c < 6; c++){
                    S[r*6+c]=sequencers[x]->GetPatternNote(s,r,c);
                }
            }
            //And store this vector in the keyfile as a list.
            kf.set_integer_list(temp,temp2,S);
        }
        //Finally, store the chord as a list of parameters.
        kf.set_integer_list(temp,FILE_KEY_SEQ_CHORD,sequencers[x]->chord.SaveToVector());
    }

    //Then, save the events.
    //For each event...
    for (unsigned int x = 0; x < events.size(); x++){
        if(events[x] == NULL) continue; //If it was removed, skip to the next one.
        //Prepare the key, according to the pattern in FILE_GROUP_TEMPLATE_EVENT...
        sprintf(temp,FILE_GROUP_TEMPLATE_EVENT,x);
        //Store some basic data.
        kf.set_integer(temp,FILE_KEY_EVENT_TYPE,events[x]->type);
        kf.set_integer(temp,FILE_KEY_EVENT_ARG1,events[x]->arg1);
        kf.set_integer(temp,FILE_KEY_EVENT_ARG2,events[x]->arg2);
        kf.set_integer(temp,FILE_KEY_EVENT_ACTIONS_NUM,events[x]->actions.size());

        //Now save all actions of this event.
        //For each action of this event...
        for (unsigned int a = 0; a < events[x]->actions.size(); a++){
            if (events[x]->actions[a] == NULL) continue;//If the action was removed, skip to the next one.
            //Save actions's data.
            sprintf(temp2,FILE_GROUP_TEMPLATE_EVENT_ACTION_TYPE,a);
            kf.set_integer(temp,temp2,events[x]->actions[a]->type);
            sprintf(temp2,FILE_GROUP_TEMPLATE_EVENT_ACTION_ARGS,a);
            kf.set_integer_list(temp,temp2,events[x]->actions[a]->args);
            sprintf(temp2,FILE_GROUP_TEMPLATE_EVENT_ACTION_CHORD,a);
            kf.set_integer_list(temp,temp2,events[x]->actions[a]->chord.SaveToVector());
        }
    }


    //Output to file. (kf.to_data() outputs plain-text output.)
    output_file << kf.to_data().c_str();

    //File is saved, we are so nice to close it.
    output_file.close();

    int found;
    //Looking for the last '/' or '\' in the file patch, and storing file name and patch in appropriate variable.
    found =  filename.find_last_of("/\\");
    file_name = filename.substr(found+1);
    file_dir = filename.substr(0,found+1);
    //If file name has changed, we have to show it in the title of the main window.
    mainwindow->UpdateTitle();
    
    
    //File has no unsaved changes now, so...
    SetFileModified(0); 
}

void LoadFileDialog(){
    Gtk::FileChooserDialog dialog(_("Choose a file to open..."),Gtk::FILE_CHOOSER_ACTION_OPEN);
    dialog.set_transient_for(*mainwindow);
    dialog.add_button(Gtk::Stock::CANCEL,Gtk::RESPONSE_CANCEL);
    dialog.add_button(Gtk::Stock::SAVE,Gtk::RESPONSE_OK);

    Gtk::FileFilter hseq;
    hseq.set_name("HarmonySEQ files (*.hseq)");
    hseq.add_pattern("*.hseq");
    dialog.add_filter(hseq);
    Gtk::FileFilter all;
    all.set_name("All files");
    all.add_pattern("*");
    dialog.add_filter(all);

    int result = dialog.run();
    Glib::ustring filename = dialog.get_filename();
    dialog.hide();
    switch (result){
        case Gtk::RESPONSE_OK:
            LoadFile(filename);
            SetFileModified(0);
            break;
        case Gtk::RESPONSE_CANCEL:
            break;
        default:
            *dbg << "unknown response returned!\n";
        break;
    }

    mainwindow->InitTreeData();
    mainwindow->main_note.set_value(mainnote);
    mainwindow->tempo_button.set_value(tempo);
    eventswindow->InitTreeData();
}


bool LoadFile(Glib::ustring file){

    *dbg << "trying to open |" << file <<"|--\n";
    int number;
    Glib::KeyFile kf;
    char temp[3000];
    char temp2[1000];
    try{
        if (!kf.load_from_file(file)) {
            sprintf(temp, _("ERROR - error while trying to read file '%s'\n"), file.c_str());
            *err << temp;
            Info(temp);
            return 1;
        }
    }catch(Glib::Error error){
        sprintf(temp, _("ERROR - error while trying to read file '%s': "), file.c_str());
        *err << temp;
        *err << error.what();
        *err << ENDL;
        Info(temp,error.what());
        return 1;

    }

    try{
        int VA = kf.get_integer("harmonySEQ","versionA");
        int VB = kf.get_integer("harmonySEQ","versionB");
        int VC = kf.get_integer("harmonySEQ","versionC");
        int slider_compatible_mode = 0;
        if (VA > VERSION_A || (VA == VERSION_A && VB > VERSION_B) || (VA == VERSION_A && VB == VERSION_B && VC > VERSION_C)){
            sprintf(temp,_("This file was created by harmonySEQ in a newer version (%d.%d.%d). This means it may contain data that is suppored by the newer wersion, but not by the version you are using (%d.%d.%d). It is recommended not to open such file, since it is very likely it may produce strange errors, or may event crash the program unexpectedly. However, in some cases one may want to open such file anyway, for example if it is sure it will open without trouble. Select YES to do so."),VA,VB,VC,VERSION_A,VERSION_B,VERSION_C);
            if (Ask(_("Do you want to open this file?"),temp,false)){
                //anserwed YES;
            }else{
                return 1;
            }

        } else if (VA < VERSION_A || (VA == VERSION_A && VB < VERSION_B) || (VA == VERSION_A && VB == VERSION_B && VC < VERSION_C)){
            sprintf(temp,_("This file was created by harmonySEQ in an older version (%d.%d.%d). This means it may miss some data that is required to be in file by the version you are using (%d.%d.%d). It is recommended not to open such file, since it is very likely it may produce strange errors, or may event crash the program unexpectedly. However, in some cases one may want to open such file anyway, for example if it is sure it will open without trouble. Select YES to do so."),VA,VB,VC,VERSION_A,VERSION_B,VERSION_C);
            if (Ask(_("Do you want to open this file?"),temp,false)){
                //anserwed YES;
                if (VA == 0 && VB <= 12) slider_compatible_mode = 1; //we'll read the slider-data and translate it to matrix-data
            }else{
                return 1;
            }
        }

        tempo = kf.get_double(FILE_GROUP_SYSTEM, FILE_KEY_SYSTEM_TEMPO);
        mainnote = kf.get_integer(FILE_GROUP_SYSTEM, FILE_KEY_SYSTEM_MAINNOTE);
        number = kf.get_integer(FILE_GROUP_SYSTEM, FILE_KEY_SYSTEM_SEQ_NUM);


        ClearSequencers(); //woa hua hua hua!

        for (int x = 0; x < number; x++) {
            
            sprintf(temp, FILE_GROUP_TEMPLATE_SEQ, x);

            if (!kf.has_group(temp)) {

                sequencers.push_back(NULL);
                continue;
            }

            sequencers.push_back(new Sequencer());

            sequencers[x]->SetName(kf.get_string(temp, FILE_KEY_SEQ_NAME));
            sequencers[x]->SetOn(kf.get_boolean(temp, FILE_KEY_SEQ_ON));
            sequencers[x]->SetChannel(kf.get_integer(temp, FILE_KEY_SEQ_CHANNEL));
            sequencers[x]->SetApplyMainNote(kf.get_boolean(temp, FILE_KEY_SEQ_APPLY_MAIN_NOTE));
            if(kf.has_key(temp,FILE_KEY_SEQ_VOLUME))
                sequencers[x]->SetVolume(kf.get_integer(temp, FILE_KEY_SEQ_VOLUME));
            else //old file. does not have volume values in it.
                sequencers[x]->SetVolume(DEFAULT_VOLUME);
            sequencers[x]->resolution = kf.get_integer(temp, FILE_KEY_SEQ_RESOLUTION);
            sequencers[x]->length = kf.get_double(temp, FILE_KEY_SEQ_LENGTH);

            sequencers[x]->patterns.clear();

            //here we load the sequences
            if(kf.has_key(temp,FILE_KEY_SEQ_SEQUENCE)){ //old file, seems it uses only one sequence, this case may be abandoned in future, since noone uses soooo old files
                    int seq = sequencers[x]->AddPattern();
                    std::vector<int> sequence = kf.get_integer_list(temp, FILE_KEY_SEQ_SEQUENCE);
                        for(int r = 0; r < sequencers[x]->resolution; r++){
                            for(int c = 0; c < 6; c++){
                                if (c == sequence[r])
                                    sequencers[x]->SetPatternNote(0,r,c,1);
                                else
                                    sequencers[x]->SetPatternNote(0,r,c,0);

                            }
                    }
            }else{//new file, uses many sequences
                int n = kf.get_integer(temp,FILE_KEY_SEQ_PATTERNS_NUMBER);
                for(int s =0; s < n; s++){
                    int seq = sequencers[x]->AddPattern();
                    sprintf(temp2,FILE_KEY_SEQ_PATTERN_TEMPLATE,s);
                    std::vector<int> sequence = kf.get_integer_list(temp, temp2);
                    
                    if (slider_compatible_mode){
                        //used to load old files <=0.12.0
                        for(int r = 0; r < sequencers[x]->resolution; r++){
                            for(int c = 0; c < 6; c++){
                                if (c == sequence[r])
                                    sequencers[x]->SetPatternNote(s,r,c,1);
                                else
                                    sequencers[x]->SetPatternNote(s,r,c,0);

                            }
                        }
                    }else{
                        for (unsigned int n = 0; n < sequence.size(); n++) {
                        //used to load new files >=0.13.0
                        for(int r = 0; r < sequencers[x]->resolution; r++){
                            for(int c = 0; c < 6; c++){
                                    sequencers[x]->SetPatternNote(s,r,c,sequence[r*6+c]);

                            }
                        }
                         }
                    }
                     
                }
                if(sequencers.size() == 0) //wtf, there were no sequences in the file? strange. We have to create one in order to prevent crashes.
                    sequencers[x]->AddPattern();

            }
            
            //here we load the chord
            if (kf.has_key(temp,FILE_KEY_SEQ_CHORD)){
                std::vector<int> vec =   kf.get_integer_list(temp,FILE_KEY_SEQ_CHORD);
                sequencers[x]->chord.SetFromVector(vec);
            }
        
            sequencers[x]->UpdateGui();
        }
        int are_there_events_in_file = kf.has_key(FILE_GROUP_SYSTEM, FILE_KEY_SYSTEM_EVENTS_NUM);
        if(!are_there_events_in_file) return 0; //THIS SHOULD BE REMOVED IN SOME NEWER VERSION, SINCE THERE ARE NOT MANY FILES OF VERSION 0.9 OR LOWER

        number = kf.get_integer(FILE_GROUP_SYSTEM, FILE_KEY_SYSTEM_EVENTS_NUM);

        ClearEvents();

        for (int x = 0; x < number; x++){
            sprintf(temp, FILE_GROUP_TEMPLATE_EVENT, x);
            if (!kf.has_group(temp)) {

                events.push_back(NULL);
                continue;
            }
            events.push_back(new Event());
            events[x]->type = kf.get_integer(temp,FILE_KEY_EVENT_TYPE);
            events[x]->arg1 = kf.get_integer(temp,FILE_KEY_EVENT_ARG1);
            events[x]->arg2 = kf.get_integer(temp,FILE_KEY_EVENT_ARG2);
            int actions_num = kf.get_integer(temp,FILE_KEY_EVENT_ACTIONS_NUM);
            for (int a = 0; a < actions_num; a++){
                sprintf(temp2,FILE_GROUP_TEMPLATE_EVENT_ACTION_TYPE,a);
                if (!kf.has_key(temp,temp2)){
                    //there is no such action in file (was removed, was a NULL pointer while saving file)
                    events[x]->actions.push_back(NULL);
                    continue;
                }
                events[x]->actions.push_back(new Action(Action::NONE));

                events[x]->actions[a]->type = kf.get_integer(temp,temp2);
                sprintf(temp2,FILE_GROUP_TEMPLATE_EVENT_ACTION_ARGS,a);
                events[x]->actions[a]->args = kf.get_integer_list(temp,temp2);
                sprintf(temp2,FILE_GROUP_TEMPLATE_EVENT_ACTION_CHORD,a);
                if (kf.has_key(temp,temp2)){
                    vector<int> vec = kf.get_integer_list(temp,temp2);
                    events[x]->actions[a]->chord.SetFromVector(vec);
                 }
                events[x]->actions[a]->GUIUpdateChordwidget();
            }

            events[x]->UpdateGUI();
        }
        //gdk_threads_enter();
        midi->Sync();
        //gdk_threads_leave();

        SetFileModified(0);
        int found =  file.find_last_of("/\\");  //Will work on linux and windos both
        file_name = file.substr(found+1);
        file_dir = file.substr(0,found+1);
        mainwindow->UpdateTitle();
        
    }catch(Glib::KeyFileError error){
        sprintf(temp, _("ERROR - Glib::KeyFile error while processing file '%s': "), file.c_str());
        *err << temp;
        *err << error.what();
        *err << ENDL;
        Info(temp,error.what());
        return 1;
        

    }catch(Glib::Error error){
        sprintf(temp, _("ERROR - unknown error while processing file '%s': "), file.c_str());
        *err << temp;
        *err << error.what();
        *err << ENDL;
        Info(temp,error.what());
        return 1;


    }
    return 0;


}
}//namespace files